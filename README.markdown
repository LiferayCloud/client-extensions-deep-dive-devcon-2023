# Client Extension Deep Dive Workshop Script

## Before Workshop

_Note that this setup might take as long as 15 minutes so please run
these steps before the workshop!_

_If you'd like help with these commands you can reach out on this Liferay community Slack channel: [#devcon-2023-client-extensions-101-workshop](https://liferay-community.slack.com/archives/C058EQJ0MFG)_

1. Download [client-extensions-deep-dive-devcon-2023.tar.gz](https://drive.google.com/uc?id=1_WnztbRVFcmo94F9zs4pHWi3_uEF73GU&export=download) and unzip

   **OR**

   Clone repo:

   ```bash
   git clone https://github.com/LiferayCloud/client-extensions-deep-dive-devcon-2023.git
   ```

1. Change into workspace

   ```bash
   cd client-extensions-deep-dive-devcon-2023
   ```

1. Initialize the bundle _(this downloads dependencies so it might take a while)_

   ```bash
   ./gradlew initBundle
   ```

1. Start DXP
   1. Linux/Mac:

      ```bash
      ./bundles/tomcat-9.0.73/bin/catalina.sh run
      ```

   1. Windows:

      ```bash
      .\bundles\tomcat-9.0.73\bin\catalina.bat run
      ```

1. Liferay should pop up automatically on http://localhost:8080

1. Log in to liferay with user `test@liferay.com` and password `test`

   _Note - if the page is unresponsive you might have to refresh the page once before logging in (known issue)._

1. Change the password to something you can remember

1. Build all projects

   ```bash
   ./gradlew build
   ```

## Workshop Exercise

### Introduction

> **What are Client Extensions again?**<br/><br/>Client extensions are a generic mechanism which enables running customizations outside Liferay.<br/><br/>They are defined in a `client-extension.yaml` file where we specify their properties.<br/><br/>When they communicate with DXP or with other Client Extensions they do so securely using OAuth2 with DXP as the Authrization Server.

In this workspace we will use Client Extensions to build the following use case:

- A ticket management system

- Requirements:
   - Defines a Customized Data Schema
   - Applies the Corporate brand and style
   - Provides a Customized User Application
   - Implements Algorithmic Documentation Referral

In the end it should look like the following image:
![Screenshot](./application-screenshot.png)

## Defining a Customized Data Schema

Our domain model is **Ticket** but DXP doesn't have the concept of a Ticket. Traditionally, we would have used Service Builder to model this but today we will use the [Objects](https://learn.liferay.com/web/guest/w/dxp/building-applications/objects) feature of DXP to define it.

### Picklist

We will start the definition of our domain model by creating some [Picklists](https://learn.liferay.com/web/guest/w/dxp/building-applications/objects/picklists/using-picklists#creating-a-picklist). A picklist is a predetermined list of values a user can select, like a vocabulary. We can use Picklists when modelling Objects where an attribute needs to be constrained to specific values. For instance; status, priority, region and so on.

The Picklists we need are already defined in the project `client-extensions/list-type-batch`.

This project's `client-extension.yaml` declares a client extension of `type: batch` (see [Batch Client Extensions](https://learn.liferay.com/w/dxp/building-applications/client-extensions/batch-client-extensions)) which is used to import DXP resources without requiring us to write any code. Resources are exported from DXP's **Import/Export Center** (_in the `JSONT` format required for client extensions_) and placed in the project's `batch` directory. Note that batch engine data files are not generated by hand. However, they are intended to be editiable by humans.

Execute the following commmand from the root of the workspace to deploy the picklists:
```bash
./gradlew :client-extensions:list-type-batch:deploy
```
Watch the tomcat logs to see that the client extension deployed.

### Object Definition

Now we can deploy our **Ticket** object (_modelled precisely as an _object definition__) which was already defined in the project `client-extensions/ticket-batch`.

Again, this project's `client-extension.yaml` declares a client extension of `type: batch`. It's `batch` directory contains the batch engine data file where the **Ticket** object is defined.

Execute the following commmand from the root of the workspace to deploy the **Ticket** object:
```bash
./gradlew :client-extensions:ticket-batch:deploy
```
Watch the tomcat logs to see that the client extension deployed.

When defining a domain model using Objects a set of headless APIs are automatically generated for you without any additional effort.

You can view these APIs in DXP's built in headless API browser by following this link: [Tickets Headless API](http://localhost:8080/o/api?endpoint=http://localhost:8080/o/c/tickets/openapi.json)

Please view the endpoints of the headless API now.

<!-- We created the first ticket by hand, but in the scenario where you have pre-existing data, you can import it using batch (several of these operations do need to be performed in order)

- deploy some pre-existing tickets

```bash
./gradlew :client-extensions:ticket-entry-batch:deploy
```

- show the ticket entries
-->

We've acheived our first business requirement: **Define a Customized Data Schema**. Let's move onto the next.

## Apply the Corporate brand and style

Most organizations, after some level of maturity, have established a brand and style which, ideally, is carried through each new project. There are a number of existing client extensions available to support this use case as opposed to traditional Theme artifact. These are a subset of the client extensions referred to collectively as [Front-End Client Extensions](https://learn.liferay.com/w/dxp/building-applications/client-extensions/front-end-client-extensions).

The `client-extensions/tickets-theme-css` project's `client-extension.yaml` declares a client extension of `type: themeCSS` (see [Theme CSS Client Extension](https://learn.liferay.com/w/dxp/building-applications/client-extensions/front-end-client-extensions/theme-css-yaml-configuration-reference)) which is used to replace the two core CSS resources from the portal's OOTB themes without modifying DXP.

Execute the following commmand from the root of the workspace to deploy the tickets-theme-css project:
```bash
./gradlew :client-extensions:tickets-theme-css:deploy
```
Watch the tomcat logs to see that the client extension deployed.

At this point let's return to the [main page of our site](http://localhost:8080). Let's apply the tickets-theme-css to the home page as demonstrated in the following video:
  ![Apply Theme to All Pages](./apply-theme.gif)

We've acheived our second business requirement: **Apply the Corporate brand and style**. Let's move onto the next.

### Provide a Customized User Application

Our next business requirement is to build a customized user application. Today in Liferay, there are low code mechanisms for doing this which directly support objects but which are not yet enabled as client extensions. So today we are going to solve this using the [Custom Element Client Extension](https://learn.liferay.com/w/dxp/building-applications/client-extensions/front-end-client-extensions/custom-element-yaml-configuration-reference) which enables use to build portal applications based on HTML 5 Web Components. In this case, using React.

The project is the `client-extensions/current-tickets-custom-element`. This project is a Javascript project with a `package.json` file that has a `.scripts.build` property which allows it to be seamlessly integrated into the workspace build (_the workspace handles this integration for you and even handles the precise Javascript build tool installation and initialization & build tasks like `$pkgman install` and `$pkgman run build`. Here in this workspace `$pkgman` is `yarn` out of preference only._)

While we inspect this project, let's take a short sidebar and consider the `client-extension.yaml`'s `assemble` block (see [Assembling Client Extensions](https://learn.liferay.com/w/dxp/building-applications/client-extensions/working-with-client-extensions#assembling-client-extensions)).

#### The `assemble` block

Note that in each of the previous projects we did already have the assemble block but let's take a minute to review it here. As was eluded to in the previous paragraph the workspace _build_ knows how to seamlessly integrate certain _none-Gradle_ builds. This is true of _most_ Front End client extensions. However it doesn't know what to include in the LUFFA.

```yaml
assemble:
    - from: build/assets
      into: static
```

The assemble block allows you to declare what resources need to be included in the LUFFA.

Execute the following commmand from the root of the workspace to deploy the current-tickets-custom-element project:
```bash
./gradlew :client-extensions:current-tickets-custom-element:deploy
```
Watch the tomcat logs to see that the client extension deployed.

At this point let's return to the [main page of our site](http://localhost:8080). Let's remove the main grid section and add the current-tickets-custom-element in place of it as demonstrated in the following video
  ![Edit Home Page to Add Custom Element](./edit-home-page.gif)

Note that this app uses the auto-generated **Ticket** headless APIs.

We've acheived our third business requirement: **Provide a Customized User Application**. Let's move onto the last.

## Implement Algorithmic Documentation Referral

Our last business requirement is to implement a business logic that will improve the speed of resolving tickets so that we can serve customers more efficiently using an algorithmic strategy to assess ticket details and adding information directly for the customer and maybe reducing the amount of research support agents need to perform in order to resolve the issue.

The `client-extensions/ticket-spring-boot` project's `client-extension.yaml` declares a client extension of `type: objectAction` (see [Object Action Client Extension](https://learn.liferay.com/w/dxp/building-applications/client-extensions/microservice-client-extensions/object-action-yaml-configuration-reference)) which enables **Object** event handler which is implemented as a REST endpoint to be registered in Liferay.

Before we proceed we will make one small change to one of the previously deployed client extensions and redeploy it. Edit the file `client-extensions/ticket-batch/batch/ticket-object-definition.batch-engine-data.json`.

On line `46` change the value of `"active"` from `false` to `true`. Save the file and then (re)execute the command:
```bash
./gradlew :client-extensions:ticket-batch:deploy
```

One small sidebar about this notion of redeployment. It is intended that all deployment operations from the workspace should be idempotent (_or that redeployments should both be effective and **not** result in error_). This is not only important as a mechanism to speed up iterative development, but as a means to move changes between environments; such as moving future changes from a DEV to UAT or UAT to PROD.

Back to the business logic.

Please take a moment to look at the file `client-extensions/ticket-spring-boot/src/main/java/com/liferay/ticket/TicketRestController.java`

The key takeaways should be that:
- the body of the request is the payload which contains all the information relevant to the object entry for which the event was triggered
- the endpoint receives and validates JWT tokens which are signed by the portal and issued specifically for the clientId provisioned for the OAuth2Application also specified in the `client-extension.yaml` using the client extension of `type: oAuthApplicationUserAgent`

**In a separate terminal**, execute the following commmand from the root of the workspace to deploy the ticket-spring-boot project and at the same time start the microservice:
```bash
(cd client-extensions/ticket-spring-boot/ && ../../gradlew deploy bootRun)
```
Watch the tomcat logs to see that the client extension deployed.

To whitness that the microservice will not allow unauthorized requests run the following curl command in a separate terminal while the microservice is running:

```bash
curl -v -X POST http://localhost:58081/ticket/object/action/documentation/referral
```

Note the response returns an error.

Finally, return to the [main page of our site](http://localhost:8080) and click the `Generate a New Ticket` button. Review the outcome and verify that:

1. a ticket was created
1. the documentation referrals are added

We've acheived our third business requirement: **Implement Algorithmic Documentation Referral**.

Try making other changes to the projects and redeploying the changes. In the case of the microservice make sure not only to execute the deploy task but also to restart it after any changes.
